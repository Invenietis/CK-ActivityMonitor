<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated/>
//
// This file is generated by ActivityMonitorSimpleSenderExtension.Group-Gen.tt
//
using System;
using System.Runtime.CompilerServices;
#nullable enable

namespace CK.Core
{
    public static partial class ActivityMonitorSimpleSenderExtension
    {
		<#
			foreach( var level in new[]{ "Debug", "Trace", "Info", "Warn", "Error", "Fatal" } )
			{
		#> 
		/// <summary>
        /// Opens a <see cref="LogLevel.<#= level #>"/> group with an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup Open<#= level #>( this IActivityMonitor monitor, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.<#= level #>, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.<#= level #>"/> group with a text message. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup Open<#= level #>( this IActivityMonitor monitor, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.<#= level #>, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.<#= level #>"/> group with a text message associated to an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup Open<#= level #>( this IActivityMonitor monitor, string text, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.<#= level #>, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #region <#= level #> with tags.

		/// <summary>
        /// Opens a <see cref="LogLevel.<#= level #>"/> group with an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IDisposableGroup Open<#= level #>( this IActivityMonitor monitor, CKTrait tags, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.<#= level #>, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.<#= level #>"/> group with a text message and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup Open<#= level #>( this IActivityMonitor monitor, CKTrait tags, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.<#= level #>, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.<#= level #>"/> group with a text message associated to an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup Open<#= level #>( this IActivityMonitor monitor, CKTrait tags, string text, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.<#= level #>, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #endregion

		<#
			}
		#> 
	}
}

