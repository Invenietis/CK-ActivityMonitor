<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated/>
//
// This file is generated by ActivityMonitorSimpleSenderExtension-Gen.tt
//
using System;
using System.Runtime.CompilerServices;
using System.ComponentModel;
#nullable enable

namespace CK.Core
{
    /// <summary>
    /// Provides OpenXXX and XXX (Debug, Trace, Info,...Fatal) extension methods for <see cref="IActivityMonitor"/>.
    /// </summary>
    public static partial class ActivityMonitorSimpleSenderExtension
    {
		<#
			foreach( var level in new[]{ "Debug", "Trace", "Info", "Warn", "Error", "Fatal" } )
			{
		#> 
		/// <summary>
        /// Emits a <see cref="LogLevel.<#= level #>"/> with an exception if it must be emitted (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>).
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static void <#= level #>( this IActivityMonitor monitor, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( monitor.ShouldLogLine( LogLevel.<#= level #>, null, out var finalTags ) )
            {
                var d = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber );
                monitor.UnfilteredLog( ref d );
            }
        }

		/// <summary>
        /// Emits a <see cref="LogLevel.<#= level #>"/> string if it must be emitted (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>).
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static void <#= level #>( this IActivityMonitor monitor, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( monitor.ShouldLogLine( LogLevel.<#= level #>, null, out var finalTags ) )
            {
                var d = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber );
                monitor.UnfilteredLog( ref d );
            }
        }

        /// <inheritdoc cref="<#= level #>(IActivityMonitor,string,int,string?)"/>
        public static void <#= level #>( this IActivityMonitor monitor,
                                [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.Line<#= level #> text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber );
                monitor.UnfilteredLog( ref line );
            }
        }

		/// <summary>
        /// Emits a <see cref="LogLevel.<#= level #>"/> string associated to an exception if it must be emitted 
        /// (this depends on <see cref="IActivityMonitor.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/>
        /// and may also depend on <see cref="IActivityMonitor.AutoTags"/>).
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static void <#= level #>( this IActivityMonitor monitor, string text, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( monitor.ShouldLogLine( LogLevel.<#= level #>, null, out var finalTags ) )
            {
                var d = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber );
                monitor.UnfilteredLog( ref d );
            }
        }

        /// <inheritdoc cref="<#= level #>(IActivityMonitor,string,Exception,int,string?)"/>
        public static void <#= level #>( this IActivityMonitor monitor,
                                [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.Line<#= level #> text,
                                Exception ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber );
                monitor.UnfilteredLog( ref line );
            }
        }

        #region <#= level #> with tags.

		/// <summary>
        /// Emits a <see cref="LogLevel.<#= level #>"/> with an exception and tags if it must be emitted (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityMonitor.AutoTags"/>).
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static void <#= level #>( this IActivityMonitor monitor, CKTrait tags, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( monitor.ShouldLogLine( LogLevel.<#= level #>, tags, out var finalTags ) )
            {
                var d = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber );
                monitor.UnfilteredLog( ref d );
            }
        }

		/// <summary>
        /// Emits a <see cref="LogLevel.<#= level #>"/> string and tags if it must be emitted (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityMonitor.AutoTags"/>).
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static void <#= level #>( this IActivityMonitor monitor, CKTrait tags, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( monitor.ShouldLogLine( LogLevel.<#= level #>, tags, out var finalTags ) )
            {
                var d = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber );
                monitor.UnfilteredLog( ref d );
            }
        }

        /// <inheritdoc cref="<#= level #>(IActivityMonitor,CKTrait,string,int,string?)"/>
        public static void <#= level #>( this IActivityMonitor monitor,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.Line<#= level #>WithTags text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber );
                monitor.UnfilteredLog( ref line );
            }
        }

		/// <summary>
        /// Emits a <see cref="LogLevel.<#= level #>"/> string associated to an exception and tags if it must be emitted 
        /// (this depends on <see cref="IActivityMonitor.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/> and may
        /// also depend on <paramref name="tags"/> and <see cref="IActivityMonitor.AutoTags"/>).
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        public static void <#= level #>( this IActivityMonitor monitor, CKTrait tags, string text, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( monitor.ShouldLogLine( LogLevel.<#= level #>, tags, out var finalTags ) )
            {
                var d = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber );
                monitor.UnfilteredLog( ref d );
            }
        }

         /// <inheritdoc cref="<#= level #>(IActivityMonitor,CKTrait,string,Exception,int,string?)"/>
        public static void <#= level #>( this IActivityMonitor monitor,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.Line<#= level #>WithTags text,
                                Exception ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = new ActivityMonitorLogData( LogLevel.<#= level #> | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber );
                monitor.UnfilteredLog( ref line );
            }
        }

       #endregion

		<#
			}
		#> 
	}

    namespace LogHandler
    {
       	<#
			foreach( var level in new[]{ "Debug", "Trace", "Info", "Warn", "Error", "Fatal" } )
			{
		#> 
    /// <summary>
    /// Provides an interpolated string handler <#= level #> lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct Line<#= level #>
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public Line<#= level #>( int literalLength, int formattedCount, IActivityMonitor monitor, out bool shouldAppend )
        {
            _handler = new InternalHandler(false, literalLength, formattedCount, monitor, LogLevel.<#= level #>, null, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler <#= level #> lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct Line<#= level #>WithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public Line<#= level #>WithTags( int literalLength, int formattedCount, IActivityMonitor monitor, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler(false, literalLength, formattedCount, monitor, LogLevel.<#= level #>, tags, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		<#
			}
		#> 
    }
}

