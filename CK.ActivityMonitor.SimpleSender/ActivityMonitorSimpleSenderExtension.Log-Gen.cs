// <auto-generated/>
//
// This file is generated by ActivityMonitorSimpleSenderExtension.Log-Gen.tt
//
using System;
using System.Runtime.CompilerServices;
using System.ComponentModel;
#nullable enable

namespace CK.Core
{
    public static partial class ActivityMonitorSimpleSenderExtension
    {
		/// <summary>
        /// Emits a <see cref="LogLevel.Debug"/> with an exception if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Debug( this IActivityLineEmitter logger, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Debug, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Debug"/> string if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Debug( this IActivityLineEmitter logger, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Debug, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Debug(IActivityLineEmitter,string,int,string?)"/>
        public static bool Debug( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineDebug text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Debug"/> string associated to an exception if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/>
        /// and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Debug( this IActivityLineEmitter logger,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Debug, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Debug(IActivityLineEmitter,string,Exception,int,string?)"/>
        public static bool Debug( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineDebug text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

        #region Debug with tags.

		    /// <summary>
        /// Emits a <see cref="LogLevel.Debug"/> with an exception and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
       [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Debug( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         Exception ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Debug, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Debug"/> string and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Debug( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string text,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Debug, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Debug(IActivityLineEmitter,CKTrait,string,int,string?)"/>
        public static bool Debug( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineDebugWithTags text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Debug"/> string associated to an exception and tags if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/> and may
        /// also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        public static bool Debug( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Debug, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Debug(IActivityLineEmitter,CKTrait,string,Exception,int,string?)"/>
        public static bool Debug( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineDebugWithTags text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

       #endregion

		/// <summary>
        /// Emits a <see cref="LogLevel.Trace"/> with an exception if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Trace( this IActivityLineEmitter logger, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Trace, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Trace"/> string if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Trace( this IActivityLineEmitter logger, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Trace, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Trace(IActivityLineEmitter,string,int,string?)"/>
        public static bool Trace( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineTrace text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Trace"/> string associated to an exception if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/>
        /// and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Trace( this IActivityLineEmitter logger,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Trace, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Trace(IActivityLineEmitter,string,Exception,int,string?)"/>
        public static bool Trace( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineTrace text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

        #region Trace with tags.

		    /// <summary>
        /// Emits a <see cref="LogLevel.Trace"/> with an exception and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
       [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Trace( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         Exception ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Trace, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Trace"/> string and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Trace( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string text,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Trace, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Trace(IActivityLineEmitter,CKTrait,string,int,string?)"/>
        public static bool Trace( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineTraceWithTags text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Trace"/> string associated to an exception and tags if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/> and may
        /// also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        public static bool Trace( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Trace, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Trace(IActivityLineEmitter,CKTrait,string,Exception,int,string?)"/>
        public static bool Trace( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineTraceWithTags text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

       #endregion

		/// <summary>
        /// Emits a <see cref="LogLevel.Info"/> with an exception if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Info( this IActivityLineEmitter logger, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Info, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Info"/> string if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Info( this IActivityLineEmitter logger, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Info, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Info(IActivityLineEmitter,string,int,string?)"/>
        public static bool Info( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineInfo text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Info"/> string associated to an exception if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/>
        /// and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Info( this IActivityLineEmitter logger,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Info, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Info(IActivityLineEmitter,string,Exception,int,string?)"/>
        public static bool Info( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineInfo text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

        #region Info with tags.

		    /// <summary>
        /// Emits a <see cref="LogLevel.Info"/> with an exception and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
       [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Info( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         Exception ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Info, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Info"/> string and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Info( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string text,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Info, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Info(IActivityLineEmitter,CKTrait,string,int,string?)"/>
        public static bool Info( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineInfoWithTags text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Info"/> string associated to an exception and tags if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/> and may
        /// also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        public static bool Info( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Info, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Info(IActivityLineEmitter,CKTrait,string,Exception,int,string?)"/>
        public static bool Info( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineInfoWithTags text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

       #endregion

		/// <summary>
        /// Emits a <see cref="LogLevel.Warn"/> with an exception if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Warn( this IActivityLineEmitter logger, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Warn, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Warn"/> string if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Warn( this IActivityLineEmitter logger, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Warn, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Warn(IActivityLineEmitter,string,int,string?)"/>
        public static bool Warn( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineWarn text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Warn"/> string associated to an exception if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/>
        /// and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Warn( this IActivityLineEmitter logger,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Warn, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Warn(IActivityLineEmitter,string,Exception,int,string?)"/>
        public static bool Warn( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineWarn text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

        #region Warn with tags.

		    /// <summary>
        /// Emits a <see cref="LogLevel.Warn"/> with an exception and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
       [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Warn( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         Exception ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Warn, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Warn"/> string and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Warn( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string text,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Warn, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Warn(IActivityLineEmitter,CKTrait,string,int,string?)"/>
        public static bool Warn( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineWarnWithTags text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Warn"/> string associated to an exception and tags if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/> and may
        /// also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        public static bool Warn( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Warn, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Warn(IActivityLineEmitter,CKTrait,string,Exception,int,string?)"/>
        public static bool Warn( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineWarnWithTags text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

       #endregion

		/// <summary>
        /// Emits a <see cref="LogLevel.Error"/> with an exception if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Error( this IActivityLineEmitter logger, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Error, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Error"/> string if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Error( this IActivityLineEmitter logger, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Error, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Error(IActivityLineEmitter,string,int,string?)"/>
        public static bool Error( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineError text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Error"/> string associated to an exception if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/>
        /// and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Error( this IActivityLineEmitter logger,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Error, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Error(IActivityLineEmitter,string,Exception,int,string?)"/>
        public static bool Error( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineError text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

        #region Error with tags.

		    /// <summary>
        /// Emits a <see cref="LogLevel.Error"/> with an exception and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
       [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Error( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         Exception ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Error, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Error"/> string and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Error( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string text,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Error, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Error(IActivityLineEmitter,CKTrait,string,int,string?)"/>
        public static bool Error( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineErrorWithTags text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Error"/> string associated to an exception and tags if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/> and may
        /// also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        public static bool Error( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Error, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Error(IActivityLineEmitter,CKTrait,string,Exception,int,string?)"/>
        public static bool Error( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineErrorWithTags text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

       #endregion

		/// <summary>
        /// Emits a <see cref="LogLevel.Fatal"/> with an exception if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Fatal( this IActivityLineEmitter logger, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Fatal, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Fatal"/> string if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Fatal( this IActivityLineEmitter logger, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Fatal, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Fatal(IActivityLineEmitter,string,int,string?)"/>
        public static bool Fatal( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineFatal text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Fatal"/> string associated to an exception if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/>
        /// and may also depend on <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Fatal( this IActivityLineEmitter logger,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Fatal, null, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Fatal(IActivityLineEmitter,string,Exception,int,string?)"/>
        public static bool Fatal( this IActivityLineEmitter logger,
                                [InterpolatedStringHandlerArgument( "logger" )] LogHandler.LineFatal text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

        #region Fatal with tags.

		    /// <summary>
        /// Emits a <see cref="LogLevel.Fatal"/> with an exception and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
       [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Fatal( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         Exception ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Fatal, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Fatal"/> string and tags if it must be emitted (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static bool Fatal( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string text,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Fatal, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Fatal(IActivityLineEmitter,CKTrait,string,int,string?)"/>
        public static bool Fatal( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineFatalWithTags text,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

		    /// <summary>
        /// Emits a <see cref="LogLevel.Fatal"/> string associated to an exception and tags if it must be emitted 
        /// (this depends on <see cref="IActivityLineEmitter.ActualFilter"/>, the global default <see cref="ActivityMonitor.DefaultFilter"/> and may
        /// also depend on <paramref name="tags"/> and <see cref="IActivityLineEmitter.AutoTags"/>).
        /// </summary>
        /// <param name="logger">This <see cref="IActivityLineEmitter"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>True if the log has been emitted, false otherwise.</returns>
        public static bool Fatal( this IActivityLineEmitter logger,
                                         CKTrait tags,
                                         string? text,
                                         Exception? ex,
                                         [CallerLineNumber]int lineNumber = 0,
                                         [CallerFilePath]string? fileName = null )
        {
            if( logger.ShouldLogLine( LogLevel.Fatal, tags, out var finalTags ) )
            {
                var d = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref d );
                return true;
            }
            return false;
        }

        /// <inheritdoc cref="Fatal(IActivityLineEmitter,CKTrait,string,Exception,int,string?)"/>
        public static bool Fatal( this IActivityLineEmitter logger,
                                CKTrait tags,
                                [InterpolatedStringHandlerArgument( "logger", "tags" )] LogHandler.LineFatalWithTags text,
                                Exception? ex,
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            if( t != null )
            {
                var line = logger.CreateActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber, false );
                logger.UnfilteredLog( ref line );
                return true;
            }
            return false;
        }

       #endregion

		 
	}

    namespace LogHandler
    {
       	 
    /// <summary>
    /// Provides an interpolated string handler for Debug lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineDebug
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineDebug( int literalLength, int formattedCount, IActivityLineEmitter logger, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Debug, null, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler for Debug lines with tags that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineDebugWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineDebugWithTags( int literalLength, int formattedCount, IActivityLineEmitter logger, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Debug, tags, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler for Trace lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineTrace
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineTrace( int literalLength, int formattedCount, IActivityLineEmitter logger, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Trace, null, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler for Trace lines with tags that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineTraceWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineTraceWithTags( int literalLength, int formattedCount, IActivityLineEmitter logger, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Trace, tags, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler for Info lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineInfo
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineInfo( int literalLength, int formattedCount, IActivityLineEmitter logger, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Info, null, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler for Info lines with tags that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineInfoWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineInfoWithTags( int literalLength, int formattedCount, IActivityLineEmitter logger, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Info, tags, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler for Warn lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineWarn
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineWarn( int literalLength, int formattedCount, IActivityLineEmitter logger, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Warn, null, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler for Warn lines with tags that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineWarnWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineWarnWithTags( int literalLength, int formattedCount, IActivityLineEmitter logger, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Warn, tags, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler for Error lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineError
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineError( int literalLength, int formattedCount, IActivityLineEmitter logger, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Error, null, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler for Error lines with tags that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineErrorWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineErrorWithTags( int literalLength, int formattedCount, IActivityLineEmitter logger, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Error, tags, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler for Fatal lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineFatal
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineFatal( int literalLength, int formattedCount, IActivityLineEmitter logger, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Fatal, null, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler for Fatal lines with tags that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct LineFatalWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public LineFatalWithTags( int literalLength, int formattedCount, IActivityLineEmitter logger, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( literalLength, formattedCount, logger, LogLevel.Fatal, tags, out shouldAppend );
        }

        public void AppendFormatted( Type t, string? format ) => _handler.AppendFormatted( t, format );

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    }
}

