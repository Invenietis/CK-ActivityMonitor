// <auto-generated/>
//
// This file is generated by ActivityMonitorSimpleSenderExtension.Group-Gen.tt
//
using System;
using System.Runtime.CompilerServices;
using System.ComponentModel;
#nullable enable

namespace CK.Core
{
    public static partial class ActivityMonitorSimpleSenderExtension
    {
		 
		/// <summary>
        /// Opens a <see cref="LogLevel.Debug"/> group with an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Debug, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Debug"/> group with a text message. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Debug, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenDebug(IActivityMonitor, string, int, string?)"/>
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupDebug text,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }


		/// <summary>
        /// Opens a <see cref="LogLevel.Debug"/> group with a text message associated to an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor,
                                                         string? text,
                                                         Exception? ex,
                                                         [CallerLineNumber]int lineNumber = 0,
                                                         [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Debug, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenDebug(IActivityMonitor, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupDebug text,
                                                  Exception? ex,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #region Debug with tags.

		/// <summary>
        /// Opens a <see cref="LogLevel.Debug"/> group with an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [CallerLineNumber]int lineNumber = 0,
                                                    [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Debug, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Debug"/> group with a text message and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor, CKTrait tags, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Debug, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenDebug(IActivityMonitor, CKTrait, string, int, string?)"/>
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupDebugWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Debug"/> group with a text message associated to an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor,
                                                CKTrait tags,
                                                string? text,
                                                Exception? ex,
                                                [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Debug, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenDebug(IActivityMonitor, CKTrait, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenDebug( this IActivityMonitor monitor,
                                                    LogLevel level,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupDebugWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Debug | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #endregion

		 
		/// <summary>
        /// Opens a <see cref="LogLevel.Trace"/> group with an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Trace, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Trace"/> group with a text message. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Trace, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenTrace(IActivityMonitor, string, int, string?)"/>
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupTrace text,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }


		/// <summary>
        /// Opens a <see cref="LogLevel.Trace"/> group with a text message associated to an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor,
                                                         string? text,
                                                         Exception? ex,
                                                         [CallerLineNumber]int lineNumber = 0,
                                                         [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Trace, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenTrace(IActivityMonitor, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupTrace text,
                                                  Exception? ex,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #region Trace with tags.

		/// <summary>
        /// Opens a <see cref="LogLevel.Trace"/> group with an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [CallerLineNumber]int lineNumber = 0,
                                                    [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Trace, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Trace"/> group with a text message and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor, CKTrait tags, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Trace, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenTrace(IActivityMonitor, CKTrait, string, int, string?)"/>
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupTraceWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Trace"/> group with a text message associated to an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor,
                                                CKTrait tags,
                                                string? text,
                                                Exception? ex,
                                                [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Trace, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenTrace(IActivityMonitor, CKTrait, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenTrace( this IActivityMonitor monitor,
                                                    LogLevel level,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupTraceWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Trace | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #endregion

		 
		/// <summary>
        /// Opens a <see cref="LogLevel.Info"/> group with an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Info, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Info"/> group with a text message. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Info, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenInfo(IActivityMonitor, string, int, string?)"/>
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupInfo text,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }


		/// <summary>
        /// Opens a <see cref="LogLevel.Info"/> group with a text message associated to an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor,
                                                         string? text,
                                                         Exception? ex,
                                                         [CallerLineNumber]int lineNumber = 0,
                                                         [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Info, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenInfo(IActivityMonitor, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupInfo text,
                                                  Exception? ex,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #region Info with tags.

		/// <summary>
        /// Opens a <see cref="LogLevel.Info"/> group with an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [CallerLineNumber]int lineNumber = 0,
                                                    [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Info, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Info"/> group with a text message and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor, CKTrait tags, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Info, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenInfo(IActivityMonitor, CKTrait, string, int, string?)"/>
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupInfoWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Info"/> group with a text message associated to an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor,
                                                CKTrait tags,
                                                string? text,
                                                Exception? ex,
                                                [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Info, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenInfo(IActivityMonitor, CKTrait, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenInfo( this IActivityMonitor monitor,
                                                    LogLevel level,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupInfoWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Info | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #endregion

		 
		/// <summary>
        /// Opens a <see cref="LogLevel.Warn"/> group with an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Warn, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Warn"/> group with a text message. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Warn, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenWarn(IActivityMonitor, string, int, string?)"/>
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupWarn text,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }


		/// <summary>
        /// Opens a <see cref="LogLevel.Warn"/> group with a text message associated to an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor,
                                                         string? text,
                                                         Exception? ex,
                                                         [CallerLineNumber]int lineNumber = 0,
                                                         [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Warn, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenWarn(IActivityMonitor, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupWarn text,
                                                  Exception? ex,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #region Warn with tags.

		/// <summary>
        /// Opens a <see cref="LogLevel.Warn"/> group with an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [CallerLineNumber]int lineNumber = 0,
                                                    [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Warn, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Warn"/> group with a text message and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor, CKTrait tags, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Warn, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenWarn(IActivityMonitor, CKTrait, string, int, string?)"/>
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupWarnWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Warn"/> group with a text message associated to an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor,
                                                CKTrait tags,
                                                string? text,
                                                Exception? ex,
                                                [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Warn, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenWarn(IActivityMonitor, CKTrait, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenWarn( this IActivityMonitor monitor,
                                                    LogLevel level,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupWarnWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Warn | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #endregion

		 
		/// <summary>
        /// Opens a <see cref="LogLevel.Error"/> group with an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenError( this IActivityMonitor monitor, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Error, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Error"/> group with a text message. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenError( this IActivityMonitor monitor, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Error, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenError(IActivityMonitor, string, int, string?)"/>
        public static IDisposableGroup OpenError( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupError text,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }


		/// <summary>
        /// Opens a <see cref="LogLevel.Error"/> group with a text message associated to an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenError( this IActivityMonitor monitor,
                                                         string? text,
                                                         Exception? ex,
                                                         [CallerLineNumber]int lineNumber = 0,
                                                         [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Error, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenError(IActivityMonitor, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenError( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupError text,
                                                  Exception? ex,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #region Error with tags.

		/// <summary>
        /// Opens a <see cref="LogLevel.Error"/> group with an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IDisposableGroup OpenError( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [CallerLineNumber]int lineNumber = 0,
                                                    [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Error, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Error"/> group with a text message and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenError( this IActivityMonitor monitor, CKTrait tags, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Error, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenError(IActivityMonitor, CKTrait, string, int, string?)"/>
        public static IDisposableGroup OpenError( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupErrorWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Error"/> group with a text message associated to an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenError( this IActivityMonitor monitor,
                                                CKTrait tags,
                                                string? text,
                                                Exception? ex,
                                                [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Error, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenError(IActivityMonitor, CKTrait, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenError( this IActivityMonitor monitor,
                                                    LogLevel level,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupErrorWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Error | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #endregion

		 
		/// <summary>
        /// Opens a <see cref="LogLevel.Fatal"/> group with an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor, Exception ex, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Fatal, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Fatal"/> group with a text message. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Fatal, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenFatal(IActivityMonitor, string, int, string?)"/>
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupFatal text,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }


		/// <summary>
        /// Opens a <see cref="LogLevel.Fatal"/> group with a text message associated to an exception. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <see cref="IActivityMonitor.AutoTags"/>),
        /// it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor,
                                                         string? text,
                                                         Exception? ex,
                                                         [CallerLineNumber]int lineNumber = 0,
                                                         [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Fatal, null, out var finalTags )
                                                ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                                : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenFatal(IActivityMonitor, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor,
                                                  [InterpolatedStringHandlerArgument( "monitor" )] LogHandler.GroupFatal text,
                                                  Exception? ex,
                                                  [CallerLineNumber] int lineNumber = 0,
                                                  [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, text._handler.FinalTags, t, ex, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #region Fatal with tags.

		/// <summary>
        /// Opens a <see cref="LogLevel.Fatal"/> group with an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [CallerLineNumber]int lineNumber = 0,
                                                    [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Fatal, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, null, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Fatal"/> group with a text message and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor, CKTrait tags, string text, [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Fatal, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, text, null, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenFatal(IActivityMonitor, CKTrait, string, int, string?)"/>
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor,
                                                    CKTrait tags,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupFatalWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

		/// <summary>
        /// Opens a <see cref="LogLevel.Fatal"/> group with a text message associated to an exception and tags. 
        /// Regardless of whether it will be emitted or not (this depends on <see cref="IActivityMonitor.ActualFilter"/>, 
        /// the global default <see cref="ActivityMonitor.DefaultFilter"/> and may also depend on <paramref name="tags"/> and
        /// <see cref="IActivityMonitor.AutoTags"/>), it must always be closed.
        /// </summary>
        /// <param name="monitor">This <see cref="IActivityMonitor"/>.</param>
        /// <param name="tags">The tags for this log.</param>
        /// <param name="text">The text to log.</param>
        /// <param name="ex">The exception to log.</param>
        /// <param name="lineNumber">Line number in the source file (automatically injected by C# compiler).</param>
        /// <param name="fileName">Source file name of the emitter (automatically injected by C# compiler).</param>
        /// <returns>A disposable object that can be used to set a function that provides a conclusion text and/or close the group.</returns>
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor,
                                                CKTrait tags,
                                                string? text,
                                                Exception? ex,
                                                [CallerLineNumber]int lineNumber = 0, [CallerFilePath]string? fileName = null )
        {
            var d = monitor.ShouldLogGroup( LogLevel.Fatal, tags, out var finalTags )
                                               ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, finalTags, text, ex, fileName, lineNumber )
                                               : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        /// <inheritdoc cref="OpenFatal(IActivityMonitor, CKTrait, string, Exception, int, string?)"/>
        public static IDisposableGroup OpenFatal( this IActivityMonitor monitor,
                                                    LogLevel level,
                                                    CKTrait tags,
                                                    Exception ex,
                                                    [InterpolatedStringHandlerArgument( "monitor", "tags" )] LogHandler.GroupFatalWithTags text,
                                                    [CallerLineNumber] int lineNumber = 0,
                                                    [CallerFilePath] string? fileName = null )
        {
            var t = text._handler.ToStringAndClear();
            var d = t != null
                    ? new ActivityMonitorLogData( LogLevel.Fatal | LogLevel.IsFiltered, text._handler.FinalTags, t, null, fileName, lineNumber )
                    : default;
            return monitor.UnfilteredOpenGroup( ref d );
        }

        #endregion

			}

    namespace LogHandler
    {
       	 
    /// <summary>
    /// Provides an interpolated string handler Debug lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupDebug
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupDebug( int literalLength, int formattedCount, IActivityMonitor monitor, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Debug, null, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler Debug lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupDebugWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupDebugWithTags( int literalLength, int formattedCount, IActivityMonitor monitor, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Debug, tags, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler Trace lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupTrace
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupTrace( int literalLength, int formattedCount, IActivityMonitor monitor, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Trace, null, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler Trace lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupTraceWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupTraceWithTags( int literalLength, int formattedCount, IActivityMonitor monitor, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Trace, tags, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler Info lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupInfo
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupInfo( int literalLength, int formattedCount, IActivityMonitor monitor, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Info, null, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler Info lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupInfoWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupInfoWithTags( int literalLength, int formattedCount, IActivityMonitor monitor, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Info, tags, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler Warn lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupWarn
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupWarn( int literalLength, int formattedCount, IActivityMonitor monitor, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Warn, null, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler Warn lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupWarnWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupWarnWithTags( int literalLength, int formattedCount, IActivityMonitor monitor, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Warn, tags, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler Error lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupError
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupError( int literalLength, int formattedCount, IActivityMonitor monitor, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Error, null, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler Error lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupErrorWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupErrorWithTags( int literalLength, int formattedCount, IActivityMonitor monitor, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Error, tags, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    /// <summary>
    /// Provides an interpolated string handler Fatal lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupFatal
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupFatal( int literalLength, int formattedCount, IActivityMonitor monitor, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Fatal, null, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }

    /// <summary>
    /// Provides an interpolated string handler Fatal lines that only performs formatting if the log must be emitted.
    /// This supports the logging framework and must not be used directly.
    /// </summary>
    [EditorBrowsable( EditorBrowsableState.Never )]
    [InterpolatedStringHandler]
    public ref struct GroupFatalWithTags
    {
        internal InternalHandler _handler;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        public GroupFatalWithTags( int literalLength, int formattedCount, IActivityMonitor monitor, CKTrait tags, out bool shouldAppend )
        {
            _handler = new InternalHandler( true, literalLength, formattedCount, monitor, LogLevel.Fatal, tags, out shouldAppend );
        }

        public void AppendLiteral( string value ) => _handler.AppendLiteral( value );

        public void AppendFormatted<T>( T value ) => _handler.AppendFormatted( value );

        public void AppendFormatted<T>( T value, string? format ) => _handler.AppendFormatted( value, format );

        public void AppendFormatted<T>( T value, int alignment ) => _handler.AppendFormatted( value, alignment );

        public void AppendFormatted<T>( T value, int alignment, string? format ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( ReadOnlySpan<char> value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( ReadOnlySpan<char> value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( string? value ) => _handler.AppendFormatted( value );

        public void AppendFormatted( string? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );

        public void AppendFormatted( object? value, int alignment = 0, string? format = null ) => _handler.AppendFormatted( value, alignment, format );
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
    }


		 
    }


}

